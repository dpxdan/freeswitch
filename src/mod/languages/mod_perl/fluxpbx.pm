# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

package fluxpbx;
use base qw(Exporter);
package fluxpbxc;
package fluxpbxc;
boot_fluxpbx();
package fluxpbx;
@EXPORT = qw();

# ---------- BASE METHODS -------------

package fluxpbx;

sub TIEHASH {
    my ($classname,$obj) = @_;
    return bless $obj, $classname;
}

sub CLEAR { }

sub FIRSTKEY { }

sub NEXTKEY { }

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "swig_${field}_get";
    $self->$member_func();
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "swig_${field}_set";
    $self->$member_func($newval);
}

sub this {
    my $ptr = shift;
    return tied(%$ptr);
}


# ------- FUNCTION WRAPPERS --------

package fluxpbx;

*setGlobalVariable = *fluxpbxc::setGlobalVariable;
*getGlobalVariable = *fluxpbxc::getGlobalVariable;
*consoleLog = *fluxpbxc::consoleLog;
*consoleLog2 = *fluxpbxc::consoleLog2;
*consoleCleanLog = *fluxpbxc::consoleCleanLog;
*running = *fluxpbxc::running;
*email = *fluxpbxc::email;
*console_log = *fluxpbxc::console_log;
*console_log2 = *fluxpbxc::console_log2;
*console_clean_log = *fluxpbxc::console_clean_log;
*msleep = *fluxpbxc::msleep;
*bridge = *fluxpbxc::bridge;
*hanguphook = *fluxpbxc::hanguphook;
*dtmf_callback = *fluxpbxc::dtmf_callback;

############# Class : fluxpbx::IVRMenu ##############

package fluxpbx::IVRMenu;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( fluxpbx );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = fluxpbxc::new_IVRMenu(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        fluxpbxc::delete_IVRMenu($self);
        delete $OWNER{$self};
    }
}

*bindAction = *fluxpbxc::IVRMenu_bindAction;
*execute = *fluxpbxc::IVRMenu_execute;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : fluxpbx::API ##############

package fluxpbx::API;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( fluxpbx );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = fluxpbxc::new_API(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        fluxpbxc::delete_API($self);
        delete $OWNER{$self};
    }
}

*execute = *fluxpbxc::API_execute;
*executeString = *fluxpbxc::API_executeString;
*getTime = *fluxpbxc::API_getTime;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : fluxpbx::input_callback_state_t ##############

package fluxpbx::input_callback_state_t;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( fluxpbx );
%OWNER = ();
%ITERATORS = ();
*swig_function_get = *fluxpbxc::input_callback_state_t_function_get;
*swig_function_set = *fluxpbxc::input_callback_state_t_function_set;
*swig_threadState_get = *fluxpbxc::input_callback_state_t_threadState_get;
*swig_threadState_set = *fluxpbxc::input_callback_state_t_threadState_set;
*swig_extra_get = *fluxpbxc::input_callback_state_t_extra_get;
*swig_extra_set = *fluxpbxc::input_callback_state_t_extra_set;
*swig_funcargs_get = *fluxpbxc::input_callback_state_t_funcargs_get;
*swig_funcargs_set = *fluxpbxc::input_callback_state_t_funcargs_set;
sub new {
    my $pkg = shift;
    my $self = fluxpbxc::new_input_callback_state_t(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        fluxpbxc::delete_input_callback_state_t($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : fluxpbx::DTMF ##############

package fluxpbx::DTMF;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( fluxpbx );
%OWNER = ();
%ITERATORS = ();
*swig_digit_get = *fluxpbxc::DTMF_digit_get;
*swig_digit_set = *fluxpbxc::DTMF_digit_set;
*swig_duration_get = *fluxpbxc::DTMF_duration_get;
*swig_duration_set = *fluxpbxc::DTMF_duration_set;
sub new {
    my $pkg = shift;
    my $self = fluxpbxc::new_DTMF(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        fluxpbxc::delete_DTMF($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : fluxpbx::Stream ##############

package fluxpbx::Stream;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( fluxpbx );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = fluxpbxc::new_Stream(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        fluxpbxc::delete_Stream($self);
        delete $OWNER{$self};
    }
}

*read = *fluxpbxc::Stream_read;
*write = *fluxpbxc::Stream_write;
*raw_write = *fluxpbxc::Stream_raw_write;
*get_data = *fluxpbxc::Stream_get_data;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : fluxpbx::Event ##############

package fluxpbx::Event;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( fluxpbx );
%OWNER = ();
%ITERATORS = ();
*swig_event_get = *fluxpbxc::Event_event_get;
*swig_event_set = *fluxpbxc::Event_event_set;
*swig_serialized_string_get = *fluxpbxc::Event_serialized_string_get;
*swig_serialized_string_set = *fluxpbxc::Event_serialized_string_set;
*swig_mine_get = *fluxpbxc::Event_mine_get;
*swig_mine_set = *fluxpbxc::Event_mine_set;
sub new {
    my $pkg = shift;
    my $self = fluxpbxc::new_Event(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        fluxpbxc::delete_Event($self);
        delete $OWNER{$self};
    }
}

*chat_execute = *fluxpbxc::Event_chat_execute;
*chat_send = *fluxpbxc::Event_chat_send;
*serialize = *fluxpbxc::Event_serialize;
*setPriority = *fluxpbxc::Event_setPriority;
*getHeader = *fluxpbxc::Event_getHeader;
*getBody = *fluxpbxc::Event_getBody;
*getType = *fluxpbxc::Event_getType;
*addBody = *fluxpbxc::Event_addBody;
*addHeader = *fluxpbxc::Event_addHeader;
*delHeader = *fluxpbxc::Event_delHeader;
*fire = *fluxpbxc::Event_fire;
*merge = *fluxpbxc::Event_merge;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : fluxpbx::EventConsumer ##############

package fluxpbx::EventConsumer;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( fluxpbx );
%OWNER = ();
%ITERATORS = ();
*swig_events_get = *fluxpbxc::EventConsumer_events_get;
*swig_events_set = *fluxpbxc::EventConsumer_events_set;
*swig_e_event_id_get = *fluxpbxc::EventConsumer_e_event_id_get;
*swig_e_event_id_set = *fluxpbxc::EventConsumer_e_event_id_set;
*swig_e_callback_get = *fluxpbxc::EventConsumer_e_callback_get;
*swig_e_callback_set = *fluxpbxc::EventConsumer_e_callback_set;
*swig_e_subclass_name_get = *fluxpbxc::EventConsumer_e_subclass_name_get;
*swig_e_subclass_name_set = *fluxpbxc::EventConsumer_e_subclass_name_set;
*swig_e_cb_arg_get = *fluxpbxc::EventConsumer_e_cb_arg_get;
*swig_e_cb_arg_set = *fluxpbxc::EventConsumer_e_cb_arg_set;
*swig_enodes_get = *fluxpbxc::EventConsumer_enodes_get;
*swig_enodes_set = *fluxpbxc::EventConsumer_enodes_set;
*swig_node_index_get = *fluxpbxc::EventConsumer_node_index_get;
*swig_node_index_set = *fluxpbxc::EventConsumer_node_index_set;
sub new {
    my $pkg = shift;
    my $self = fluxpbxc::new_EventConsumer(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        fluxpbxc::delete_EventConsumer($self);
        delete $OWNER{$self};
    }
}

*bind = *fluxpbxc::EventConsumer_bind;
*pop = *fluxpbxc::EventConsumer_pop;
*cleanup = *fluxpbxc::EventConsumer_cleanup;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : fluxpbx::CoreSession ##############

package fluxpbx::CoreSession;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( fluxpbx );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        fluxpbxc::delete_CoreSession($self);
        delete $OWNER{$self};
    }
}

*swig_session_get = *fluxpbxc::CoreSession_session_get;
*swig_session_set = *fluxpbxc::CoreSession_session_set;
*swig_channel_get = *fluxpbxc::CoreSession_channel_get;
*swig_channel_set = *fluxpbxc::CoreSession_channel_set;
*swig_flags_get = *fluxpbxc::CoreSession_flags_get;
*swig_flags_set = *fluxpbxc::CoreSession_flags_set;
*swig_allocated_get = *fluxpbxc::CoreSession_allocated_get;
*swig_allocated_set = *fluxpbxc::CoreSession_allocated_set;
*swig_cb_state_get = *fluxpbxc::CoreSession_cb_state_get;
*swig_cb_state_set = *fluxpbxc::CoreSession_cb_state_set;
*swig_hook_state_get = *fluxpbxc::CoreSession_hook_state_get;
*swig_hook_state_set = *fluxpbxc::CoreSession_hook_state_set;
*swig_cause_get = *fluxpbxc::CoreSession_cause_get;
*swig_cause_set = *fluxpbxc::CoreSession_cause_set;
*swig_uuid_get = *fluxpbxc::CoreSession_uuid_get;
*swig_uuid_set = *fluxpbxc::CoreSession_uuid_set;
*swig_tts_name_get = *fluxpbxc::CoreSession_tts_name_get;
*swig_tts_name_set = *fluxpbxc::CoreSession_tts_name_set;
*swig_voice_name_get = *fluxpbxc::CoreSession_voice_name_get;
*swig_voice_name_set = *fluxpbxc::CoreSession_voice_name_set;
*insertFile = *fluxpbxc::CoreSession_insertFile;
*answer = *fluxpbxc::CoreSession_answer;
*print = *fluxpbxc::CoreSession_print;
*preAnswer = *fluxpbxc::CoreSession_preAnswer;
*hangup = *fluxpbxc::CoreSession_hangup;
*hangupState = *fluxpbxc::CoreSession_hangupState;
*setVariable = *fluxpbxc::CoreSession_setVariable;
*setPrivate = *fluxpbxc::CoreSession_setPrivate;
*getPrivate = *fluxpbxc::CoreSession_getPrivate;
*getVariable = *fluxpbxc::CoreSession_getVariable;
*process_callback_result = *fluxpbxc::CoreSession_process_callback_result;
*say = *fluxpbxc::CoreSession_say;
*sayPhrase = *fluxpbxc::CoreSession_sayPhrase;
*hangupCause = *fluxpbxc::CoreSession_hangupCause;
*getState = *fluxpbxc::CoreSession_getState;
*recordFile = *fluxpbxc::CoreSession_recordFile;
*originate = *fluxpbxc::CoreSession_originate;
*destroy = *fluxpbxc::CoreSession_destroy;
*setDTMFCallback = *fluxpbxc::CoreSession_setDTMFCallback;
*speak = *fluxpbxc::CoreSession_speak;
*set_tts_parms = *fluxpbxc::CoreSession_set_tts_parms;
*set_tts_params = *fluxpbxc::CoreSession_set_tts_params;
*collectDigits = *fluxpbxc::CoreSession_collectDigits;
*getDigits = *fluxpbxc::CoreSession_getDigits;
*transfer = *fluxpbxc::CoreSession_transfer;
*read = *fluxpbxc::CoreSession_read;
*detectSpeech = *fluxpbxc::CoreSession_detectSpeech;
*playAndGetDigits = *fluxpbxc::CoreSession_playAndGetDigits;
*playAndDetectSpeech = *fluxpbxc::CoreSession_playAndDetectSpeech;
*streamFile = *fluxpbxc::CoreSession_streamFile;
*sleep = *fluxpbxc::CoreSession_sleep;
*flushEvents = *fluxpbxc::CoreSession_flushEvents;
*flushDigits = *fluxpbxc::CoreSession_flushDigits;
*setAutoHangup = *fluxpbxc::CoreSession_setAutoHangup;
*setHangupHook = *fluxpbxc::CoreSession_setHangupHook;
*ready = *fluxpbxc::CoreSession_ready;
*bridged = *fluxpbxc::CoreSession_bridged;
*answered = *fluxpbxc::CoreSession_answered;
*mediaReady = *fluxpbxc::CoreSession_mediaReady;
*waitForAnswer = *fluxpbxc::CoreSession_waitForAnswer;
*execute = *fluxpbxc::CoreSession_execute;
*sendEvent = *fluxpbxc::CoreSession_sendEvent;
*setEventData = *fluxpbxc::CoreSession_setEventData;
*getXMLCDR = *fluxpbxc::CoreSession_getXMLCDR;
*begin_allow_threads = *fluxpbxc::CoreSession_begin_allow_threads;
*end_allow_threads = *fluxpbxc::CoreSession_end_allow_threads;
*get_uuid = *fluxpbxc::CoreSession_get_uuid;
*get_cb_args = *fluxpbxc::CoreSession_get_cb_args;
*check_hangup_hook = *fluxpbxc::CoreSession_check_hangup_hook;
*run_dtmf_callback = *fluxpbxc::CoreSession_run_dtmf_callback;
*consoleLog = *fluxpbxc::CoreSession_consoleLog;
*consoleLog2 = *fluxpbxc::CoreSession_consoleLog2;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : fluxpbx::Session ##############

package fluxpbx::Session;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( fluxpbx::CoreSession fluxpbx );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = fluxpbxc::new_Session(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        fluxpbxc::delete_Session($self);
        delete $OWNER{$self};
    }
}

*destroy = *fluxpbxc::Session_destroy;
*begin_allow_threads = *fluxpbxc::Session_begin_allow_threads;
*end_allow_threads = *fluxpbxc::Session_end_allow_threads;
*check_hangup_hook = *fluxpbxc::Session_check_hangup_hook;
*run_dtmf_callback = *fluxpbxc::Session_run_dtmf_callback;
*setME = *fluxpbxc::Session_setME;
*setInputCallback = *fluxpbxc::Session_setInputCallback;
*unsetInputCallback = *fluxpbxc::Session_unsetInputCallback;
*setHangupHook = *fluxpbxc::Session_setHangupHook;
*ready = *fluxpbxc::Session_ready;
*swig_callback_mutex_get = *fluxpbxc::Session_callback_mutex_get;
*swig_callback_mutex_set = *fluxpbxc::Session_callback_mutex_set;
*swig_destroying_get = *fluxpbxc::Session_destroying_get;
*swig_destroying_set = *fluxpbxc::Session_destroying_set;
*swig_event_idx_get = *fluxpbxc::Session_event_idx_get;
*swig_event_idx_set = *fluxpbxc::Session_event_idx_set;
*swig_suuid_get = *fluxpbxc::Session_suuid_get;
*swig_suuid_set = *fluxpbxc::Session_suuid_set;
*swig_cb_function_get = *fluxpbxc::Session_cb_function_get;
*swig_cb_function_set = *fluxpbxc::Session_cb_function_set;
*swig_cb_arg_get = *fluxpbxc::Session_cb_arg_get;
*swig_cb_arg_set = *fluxpbxc::Session_cb_arg_set;
*swig_hangup_func_str_get = *fluxpbxc::Session_hangup_func_str_get;
*swig_hangup_func_str_set = *fluxpbxc::Session_hangup_func_str_set;
*swig_hangup_func_arg_get = *fluxpbxc::Session_hangup_func_arg_get;
*swig_hangup_func_arg_set = *fluxpbxc::Session_hangup_func_arg_set;
*setPERL = *fluxpbxc::Session_setPERL;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


# ------- VARIABLE STUBS --------

package fluxpbx;

*S_HUP = *fluxpbxc::S_HUP;
*S_FREE = *fluxpbxc::S_FREE;
*S_RDLOCK = *fluxpbxc::S_RDLOCK;
1;
